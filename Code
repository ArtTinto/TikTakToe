import java.util.Random;
import java.util.Scanner;

public class TikTakToe {

    public static void print_velha(char mat[][]) {
        for (int i = 0; i < mat.length; i++) {
            System.out.println();
            for (int j = 0; j < mat[i].length - 1; j++) {
                print_char(mat[i][j]);
                print_char('|');
            }
            print_char(mat[i][2]);

            System.out.println();
            for (int k = 0; k < 11; k++) {
                print_char('-');
            }
        }
        System.out.println();

    }

    public static void print_char(char character) {

        // Color if x
        if (character == 'x') {
            System.out.print("\u001B[34m " + character + "\u001B[0m");
        }
        // Color if o
        else if (character == 'o') {
            System.out.print("\u001B[31m " + character + "\u001B[0m");
        }
        // Color if |
        else if (character == '|') {
            System.out.print("\u001B[33m " + character + "\u001B[0m");
        }
        // Color if -
        else if (character == '-') {
            System.out.print("\u001B[33m" + character + "\u001B[0m");
        }
        // Color if letters a to i
        else {
            System.out.print("\u001B[32m " + character + "\u001B[0m");
        }

    }

    public static char getWinner(char mat[][]) {
        for (int i = 0; i < mat.length; i++) {
            for (int j = 0; j < mat[i].length; j++) {

                if (j + 2 < mat[i].length) {
                    // Check all rows
                    if (mat[i][j] == mat[i][j + 1] && mat[i][j] == mat[i][j + 2]) {
                        return mat[i][j];
                    }
                }

                if (i + 2 < mat[i].length) {
                    // Check all columns
                    if (mat[i][j] == mat[i + 1][j] && mat[i][j] == mat[i + 2][j]) {
                        return mat[i][j];
                    }

                    // Check Main Diagonal
                    if (mat[i][i] == mat[i + 1][i + 1] && mat[i][i] == mat[i + 2][i + 2]) {
                        return mat[i][i];
                    }

                    // Check Secundary Diagonal
                    if (mat[i][mat[i].length - 1] == mat[i + 1][mat[i].length - 2]
                            && mat[i][mat[i].length - 1] == mat[i + 2][mat[i].length - 3]) {
                        return mat[i][mat[i].length - 1];
                    }
                }
            }
        }
        // Return blank in case no one won
        return ' ';
    }

    // Return pos [row, column] where CPU has to block
    public static int[] findThreat(char[][] mat) {
        // Check all rows and columns
        // Return [i, j] of the position that can be won
        int[] pos = new int[2];

        // Check if CPU can win
        pos = recognizePattern(mat, 'o');
        if (pos != null)
            return pos;

        // If can't won, tries blocking the player
        pos = recognizePattern(mat, 'x');
        if (pos != null)
            return pos;

        // Don't have a specific play
        return null;
    }

    public static int[] recognizePattern(char[][] mat, char simbol) {
        // Check Rows
        for (int i = 0; i < 3; i++) {
            int count = 0;
            int blank = -1;
            for (int j = 0; j < 3; j++) {
                if (mat[i][j] == simbol)
                    count++;
                else if (mat[i][j] != 'x' && mat[i][j] != 'o')
                    blank = j;
            }
            if (count == 2 && blank != -1)
                return new int[] { i, blank };
        }

        // Check Columns
        for (int j = 0; j < 3; j++) {
            int count = 0;
            int blank = -1;
            for (int i = 0; i < 3; i++) {
                if (mat[i][j] == simbol)
                    count++;
                else if (mat[i][j] != 'x' && mat[i][j] != 'o')
                    blank = i;
            }
            if (count == 2 && blank != -1)
                return new int[] { blank, j };
        }

        // Check Main Diagonal
        int countDiag = 0, blankDiag = -1;
        for (int i = 0; i < 3; i++) {
            if (mat[i][i] == simbol)
                countDiag++;
            else if (mat[i][i] != 'x' && mat[i][i] != 'o')
                blankDiag = i;
        }
        if (countDiag == 2 && blankDiag != -1)
            return new int[] { blankDiag, blankDiag };

        // Check Secundary Diagonal
        countDiag = 0;
        blankDiag = -1;
        for (int i = 0; i < 3; i++) {
            if (mat[i][2 - i] == simbol)
                countDiag++;
            else if (mat[i][2 - i] != 'x' && mat[i][2 - i] != 'o')
                blankDiag = i;
        }
        if (countDiag == 2 && blankDiag != -1)
            return new int[] { blankDiag, 2 - blankDiag };

        // If hasn't a threat return null
        return null;
    }

    public static boolean cpuPlayEasy(char[][] position, int qtd_plays, Random random) {
        int playCPU = random.nextInt(9 - qtd_plays);

        for (int i = 0; i < position.length; i++) {
            for (int j = 0; j < position[i].length; j++) {
                // Skip occupied cells
                if (position[i][j] == 'x' || position[i][j] == 'o')
                    continue;

                // When the random counter reaches zero, play here
                if (playCPU == 0) {
                    position[i][j] = 'o';
                    return true;
                }

                playCPU--;
            }
        }

        return false; // CPU couldn't play (should never happen)
    }

    public static boolean cpuPlayHard(char[][] position) {
        int[] threat = findThreat(position);

        // If a winning or blocking move exists, play there
        if (threat != null) {
            position[threat[0]][threat[1]] = 'o';
            return true;
        }

        // Otherwise, play randomly like the easy mode
        Random random = new Random();
        return cpuPlayEasy(position, countPlays(position), random);
    }

    // Counts total number of moves made on the board
    public static int countPlays(char[][] mat) {
        int count = 0;
        for (int i = 0; i < mat.length; i++) {
            for (int j = 0; j < mat[i].length; j++) {
                if (mat[i][j] == 'x' || mat[i][j] == 'o')
                    count++;
            }
        }
        return count;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        Random random = new Random();
        char play;
        int qtd_plays = 0;
        int dificuldade;

        do {
            System.out.print("Escolha a dificuldade:\n1 - Fácil\n2 - Difícil\n");
            while (!scanner.hasNextInt()) {
                System.out.print("Digite apenas 1 ou 2: ");
                scanner.next();
            }
            dificuldade = scanner.nextInt();
            scanner.nextLine();
        } while (dificuldade != 1 && dificuldade != 2);

        // Creates an array with the position in game
        char position[][] = { { 'a', 'b', 'c' }, { 'd', 'e', 'f' }, { 'g', 'h', 'i' } };

        for (;;) {
            print_velha(position);
            System.out.println();

            boolean valid;
            boolean isOcupidy;
            do {
                // Get player play
                System.out.print("\u001B[31mSUA VEZ\u001B[0m\n\u001B[35mDigite a letra da posição desejada: \u001B[0m");
                play = scanner.next().toLowerCase().charAt(0);
                System.out.println();

                // Looks if the player char is valid in the matriz position
                // is like doing a if char between the ASCII
                valid = (play >= 'a' && play <= 'i');
                isOcupidy = false;

                // Show a message if the input is invalid
                if (!valid) {
                    System.out.println("\u001B[33mPosição inválida! Digite uma letra de 'a' a 'i'.\u001B[0m\n");
                } else {
                    // Check if the position is ocupidy
                    boolean find = false;
                    for (int i = 0; i < position.length; i++) {
                        for (int j = 0; j < position[i].length; j++) {
                            if (position[i][j] == play) {
                                find = true;
                            }
                        }
                    }

                    if (!find) {
                        isOcupidy = true;
                        System.out.println("\u001B[33mEssa posição já está ocupada! Escolha outra.\u001B[0m\n");
                    }
                }

            } while (!valid || isOcupidy);

            // Check the x player play to switch it to x
            for (int i = 0; i < position.length; i++) {
                for (int j = 0; j < position[i].length; j++) {
                    if (position[i][j] == play) {
                        position[i][j] = 'x';
                        qtd_plays++;
                    }
                }
            }

            if (qtd_plays < 9) {
                boolean hasPlayed = false;

                // Choose CPU difficulty mode
                if (dificuldade == 2) {
                    hasPlayed = cpuPlayHard(position);
                } else {
                    hasPlayed = cpuPlayEasy(position, qtd_plays, random);
                }

                if (hasPlayed)
                    qtd_plays++;
            }
            // Check if someone has winned
            char winner = getWinner(position);

            // Exhib a message if the player has winned
            if (winner == 'x') {
                // Print the last array
                print_velha(position);
                for (int i = 40; i <= 47; i++) {

                    // Fun print
                    System.out.print("\u001B[" + i + "mCongrats, You Won!!\u001B[0m\n");
                    try {
                        Thread.sleep(500);
                    } catch (Exception e) {
                    }
                }
                break;
            }
            // Exhib a message if the CPU has winned
            else if (winner == 'o') {
                // Print the last array
                print_velha(position);
                for (int i = 40; i <= 47; i++) {

                    // Fun print
                    System.out.print("\u001B[" + i + "mDude, You Lost To a CPU!!\u001B[0m\n");
                    try {
                        Thread.sleep(1000);
                    } catch (Exception e) {
                    }
                }
                break;
            }
            // If hasn't winners then ends
            if (qtd_plays == 9) {
                System.out.println("Deu Velha");
                break;
            }
        }

        scanner.close();
    }
}
